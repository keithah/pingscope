---
phase: 17-widget-foundation
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - PingScopeWidget/PingScopeWidget.swift
  - PingScopeWidget/PingScopeWidgetProvider.swift
  - PingScopeWidget/PingScopeWidgetEntry.swift
  - PingScopeWidget/Views/SmallWidgetView.swift
  - PingScopeWidget/Views/MediumWidgetView.swift
  - PingScopeWidget/Views/LargeWidgetView.swift
  - PingScopeWidget/PingScopeWidgetView.swift
autonomous: true
requirements:
  - WI-06
  - WI-07
  - WUI-01
  - WUI-02
  - WUI-03
  - WUI-04
  - WUI-05
  - WUI-06
  - WUI-07
  - WUI-09
  - WUI-10

must_haves:
  truths:
    - Widget appears in macOS widget gallery showing PingScope
    - Small widget displays single host with status and latency
    - Medium widget displays 3 hosts with status indicators
    - Large widget displays all hosts with statistics
    - Widgets adapt to light and dark mode automatically
    - Stale data (>15min) shows reduced opacity and warning
  artifacts:
    - path: "PingScopeWidget/PingScopeWidgetProvider.swift"
      provides: "TimelineProvider reading from shared UserDefaults"
      exports: ["Provider"]
    - path: "PingScopeWidget/Views/SmallWidgetView.swift"
      provides: "Single host widget view"
      min_lines: 50
    - path: "PingScopeWidget/Views/MediumWidgetView.swift"
      provides: "Three host summary view"
      min_lines: 50
    - path: "PingScopeWidget/Views/LargeWidgetView.swift"
      provides: "All hosts list view"
      min_lines: 60
  key_links:
    - from: "PingScopeWidget/PingScopeWidgetProvider.swift"
      to: "shared UserDefaults"
      via: "loadData() method"
      pattern: "UserDefaults\\(suiteName:"
    - from: "PingScopeWidget/PingScopeWidget.swift"
      to: "Provider"
      via: "StaticConfiguration"
      pattern: "StaticConfiguration.*Provider"

---

<objective>
Implement WidgetKit TimelineProvider and all three widget size views (small/medium/large) with proper timeline scheduling, status colors, dark mode support, and stale data indicators.

Purpose: Create the complete widget UI displaying live ping status in all supported sizes
Output: Functional widgets appearing in macOS widget gallery with proper data display and appearance
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-widget-foundation/17-RESEARCH.md
@.planning/phases/17-widget-foundation/17-01-SUMMARY.md
@Sources/PingScope/Widget/WidgetData.swift
</context>

<tasks>

<task type="auto">
  <name>Implement TimelineProvider and Widget Entry</name>
  <files>
    PingScopeWidget/PingScopeWidgetProvider.swift
    PingScopeWidget/PingScopeWidgetEntry.swift
  </files>
  <action>
Create WidgetKit TimelineProvider that reads cached data from shared UserDefaults:

1. **Create PingScopeWidget/PingScopeWidgetEntry.swift:**
```swift
import WidgetKit

struct WidgetEntry: TimelineEntry {
    let date: Date
    let data: WidgetData?

    var relevance: TimelineEntryRelevance? {
        guard let data = data else { return nil }

        // Higher relevance score for unhealthy hosts (promotes in Smart Stack)
        let hasIssues = data.results.contains { !$0.isSuccess }
        return TimelineEntryRelevance(
            score: hasIssues ? 100 : 50,
            duration: 15 * 60  // 15 minutes
        )
    }
}
```

2. **Create PingScopeWidget/PingScopeWidgetProvider.swift:**
```swift
import WidgetKit
import SwiftUI

struct Provider: TimelineProvider {
    private let groupIdentifier = "TEAMID.group.com.hadm.PingScope"  // Use same from Plan 01

    func placeholder(in context: Context) -> WidgetEntry {
        WidgetEntry(date: Date(), data: .placeholder)
    }

    func getSnapshot(in context: Context, completion: @escaping (WidgetEntry) -> Void) {
        let entry = WidgetEntry(date: Date(), data: loadData())
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<WidgetEntry>) -> Void) {
        let data = loadData()
        let entry = WidgetEntry(date: Date(), data: data)

        // Next update in 10 minutes (respects 40-70/day budget)
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 10, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))

        completion(timeline)
    }

    private func loadData() -> WidgetData? {
        guard let shared = UserDefaults(suiteName: groupIdentifier),
              let data = shared.data(forKey: "widgetData"),
              let decoded = try? JSONDecoder().decode(WidgetData.self, from: data) else {
            return nil
        }
        return decoded
    }
}
```

Timeline spacing: 10 minutes fits 144 updates/day, well within 40-70 system budget. Main app calls reloadTimelines() on data change for immediate updates.
  </action>
  <verify>
Run: swift build
Confirm: PingScopeWidget target compiles
Confirm: Provider implements all TimelineProvider protocol methods
Confirm: Timeline policy uses .after(date) with 10-minute spacing
  </verify>
  <done>
TimelineProvider exists reading from shared UserDefaults with 10-minute baseline refresh interval and relevance scoring for Smart Stack promotion.
  </done>
</task>

<task type="auto">
  <name>Create Widget Size Views (Small, Medium, Large)</name>
  <files>
    PingScopeWidget/Views/SmallWidgetView.swift
    PingScopeWidget/Views/MediumWidgetView.swift
    PingScopeWidget/Views/LargeWidgetView.swift
  </files>
  <action>
Create three widget size views following macOS WidgetKit design patterns:

**Design decisions (Claude's discretion):**
- Status colors: green (<50ms), yellow (50-100ms), red (>100ms or timeout)
- Stale indicator: 60% opacity + orange warning badge when >15min old
- Typography: .headline for titles, .title2 for latency, .caption2 for timestamps
- Host selection (medium): Show first 3 hosts (future: prioritize unhealthy)

1. **Create PingScopeWidget/Views/SmallWidgetView.swift:**
```swift
import SwiftUI
import WidgetKit

struct SmallWidgetView: View {
    let entry: WidgetEntry

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            if let data = entry.data,
               let host = data.hosts.first,
               let result = data.results.first {

                HStack {
                    Circle()
                        .fill(statusColor(for: result))
                        .frame(width: 12, height: 12)

                    Text(host.name)
                        .font(.headline)
                        .lineLimit(1)
                }

                if let latency = result.latencyMS {
                    Text(String(format: "%.1f ms", latency))
                        .font(.system(.title2, design: .rounded))
                        .fontWeight(.bold)
                } else {
                    Text("Timeout")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                Text(entry.date, style: .relative)
                    .font(.caption2)
                    .foregroundColor(.secondary)

                if data.isStale {
                    HStack(spacing: 4) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption2)
                            .foregroundColor(.orange)
                        Text("Stale")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                }
            } else {
                Text("No Data")
                    .foregroundColor(.secondary)
            }
        }
        .opacity(entry.data?.isStale == true ? 0.6 : 1.0)
        .containerBackground(for: .widget) {
            Color(nsColor: .controlBackgroundColor)
        }
    }

    private func statusColor(for result: WidgetData.SimplifiedPingResult) -> Color {
        guard result.isSuccess, let latency = result.latencyMS else { return .red }
        if latency < 50 { return .green }
        if latency < 100 { return .yellow }
        return .red
    }
}
```

2. **Create PingScopeWidget/Views/MediumWidgetView.swift:**
```swift
import SwiftUI
import WidgetKit

struct MediumWidgetView: View {
    let entry: WidgetEntry

    var body: some View {
        HStack(spacing: 12) {
            if let data = entry.data {
                ForEach(Array(zip(data.hosts.prefix(3), data.results.prefix(3))), id: \.0.id) { host, result in
                    VStack(alignment: .leading, spacing: 4) {
                        HStack(spacing: 4) {
                            Circle()
                                .fill(statusColor(for: result))
                                .frame(width: 8, height: 8)

                            Text(host.name)
                                .font(.caption)
                                .fontWeight(.medium)
                                .lineLimit(1)
                        }

                        if let latency = result.latencyMS {
                            Text(String(format: "%.1f ms", latency))
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        } else {
                            Text("Timeout")
                                .font(.caption2)
                                .foregroundColor(.red)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }

                if data.isStale {
                    VStack {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption)
                            .foregroundColor(.orange)
                    }
                }
            }
        }
        .opacity(entry.data?.isStale == true ? 0.6 : 1.0)
        .containerBackground(for: .widget) {
            Color(nsColor: .controlBackgroundColor)
        }
    }

    private func statusColor(for result: WidgetData.SimplifiedPingResult) -> Color {
        guard result.isSuccess, let latency = result.latencyMS else { return .red }
        if latency < 50 { return .green }
        if latency < 100 { return .yellow }
        return .red
    }
}
```

3. **Create PingScopeWidget/Views/LargeWidgetView.swift:**
```swift
import SwiftUI
import WidgetKit

struct LargeWidgetView: View {
    let entry: WidgetEntry

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("PingScope")
                    .font(.headline)

                Spacer()

                if let data = entry.data {
                    Text(data.lastUpdate, style: .relative)
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    if data.isStale {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                }
            }

            Divider()

            if let data = entry.data {
                ForEach(Array(zip(data.hosts, data.results)), id: \.0.id) { host, result in
                    HStack {
                        Circle()
                            .fill(statusColor(for: result))
                            .frame(width: 10, height: 10)

                        Text(host.name)
                            .font(.subheadline)
                            .lineLimit(1)

                        Spacer()

                        if let latency = result.latencyMS {
                            Text(String(format: "%.1f ms", latency))
                                .font(.caption)
                                .foregroundColor(.secondary)
                        } else {
                            Text("Timeout")
                                .font(.caption)
                                .foregroundColor(.red)
                        }
                    }
                }
            }

            Spacer()
        }
        .opacity(entry.data?.isStale == true ? 0.6 : 1.0)
        .containerBackground(for: .widget) {
            Color(nsColor: .controlBackgroundColor)
        }
    }

    private func statusColor(for result: WidgetData.SimplifiedPingResult) -> Color {
        guard result.isSuccess, let latency = result.latencyMS else { return .red }
        if latency < 50 { return .green }
        if latency < 100 { return .yellow }
        return .red
    }
}
```

All views use system colors for automatic dark mode support. Stale data (>15min) shows at 60% opacity with warning indicators.
  </action>
  <verify>
Run: swift build
Confirm: All three widget view files compile
Confirm: Status colors use .green/.yellow/.red system colors
Confirm: Stale indicator logic checks data.isStale
Confirm: Typography uses .headline, .title2, .caption2 fonts
  </verify>
  <done>
Three widget size views exist with color-coded status indicators, latency display, stale data handling, and automatic dark mode support via system colors.
  </done>
</task>

<task type="auto">
  <name>Create Widget Configuration and Main Entry Point</name>
  <files>
    PingScopeWidget/PingScopeWidget.swift
    PingScopeWidget/PingScopeWidgetView.swift
  </files>
  <action>
Create widget configuration and family-switching view:

1. **Create PingScopeWidget/PingScopeWidgetView.swift:**
```swift
import SwiftUI
import WidgetKit

struct PingScopeWidgetView: View {
    @Environment(\.widgetFamily) var family
    let entry: WidgetEntry

    var body: some View {
        switch family {
        case .systemSmall:
            SmallWidgetView(entry: entry)
        case .systemMedium:
            MediumWidgetView(entry: entry)
        case .systemLarge:
            LargeWidgetView(entry: entry)
        @unknown default:
            EmptyView()
        }
    }
}
```

2. **Create PingScopeWidget/PingScopeWidget.swift:**
```swift
import WidgetKit
import SwiftUI

@main
struct PingScopeWidget: Widget {
    let kind: String = "PingScopeWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider()) { entry in
            PingScopeWidgetView(entry: entry)
                .containerBackground(for: .widget) {
                    Color.clear
                }
        }
        .configurationDisplayName("PingScope")
        .description("Monitor ping status and latency")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}
```

Widget now appears in macOS widget gallery under "PingScope" name.
  </action>
  <verify>
Run: swift build
Confirm: PingScopeWidget compiles with @main attribute
Confirm: StaticConfiguration uses Provider and PingScopeWidgetView
Confirm: supportedFamilies includes all three sizes
  </verify>
  <done>
Widget configuration exists supporting small/medium/large families with proper display name and description for widget gallery.
  </done>
</task>

</tasks>

<verification>
1. TimelineProvider reads from shared UserDefaults
2. Timeline entries spaced 10 minutes apart (respects budget)
3. All three widget sizes render with proper layouts
4. Status colors use system colors (green/yellow/red)
5. Stale data shows reduced opacity and warning indicators
6. Widget views use semantic colors for dark mode compatibility
</verification>

<success_criteria>
- Widget extension builds and links successfully
- All three widget sizes compile and follow WidgetKit patterns
- Status color scheme implemented (green/yellow/red thresholds)
- Stale data indicator (>15min) shows at 60% opacity with badge
- Dark mode support via system colors (.primary, .secondary, .controlBackgroundColor)
</success_criteria>

<output>
After completion, create `.planning/phases/17-widget-foundation/17-02-SUMMARY.md`
</output>
