---
phase: 06-notifications-settings
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - Sources/PingScope/Models/HostAlertState.swift
  - Sources/PingScope/Services/NotificationService.swift
  - Sources/PingScope/Services/AlertDetector.swift
autonomous: true

must_haves:
  truths:
    - "Alert fires when host transitions from up to down (no response)"
    - "Alert fires when ping latency exceeds threshold"
    - "Alert fires when host recovers from failure"
    - "Alert fires when latency degrades by configured percentage"
    - "Alert fires on intermittent failures (N in M window)"
    - "Alert fires when gateway IP changes"
    - "Alert fires when all hosts fail (internet loss)"
    - "Cooldown prevents repeated alerts of same type for same host"
  artifacts:
    - path: "Sources/PingScope/Models/HostAlertState.swift"
      provides: "Per-host alert tracking state"
      contains: "struct HostAlertState"
    - path: "Sources/PingScope/Services/AlertDetector.swift"
      provides: "Logic to detect all 7 alert conditions"
      contains: "struct AlertDetector"
  key_links:
    - from: "AlertDetector"
      to: "HostAlertState"
      via: "state mutation for detection"
      pattern: "HostAlertState"
    - from: "NotificationService"
      to: "AlertDetector"
      via: "evaluate ping result"
      pattern: "AlertDetector\\.(detect|evaluate)"
---

<objective>
Implement alert detection logic for all 7 notification types with per-host state tracking and cooldown enforcement.

Purpose: Enable the notification system to intelligently detect network conditions that warrant user alerts.
Output: Complete alert detection covering no response, high latency, recovery, degradation, intermittent, network change, and internet loss.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notifications-settings/06-RESEARCH.md
@.planning/phases/06-notifications-settings/06-01-SUMMARY.md

# Existing models
@Sources/PingScope/Models/PingResult.swift
@Sources/PingScope/Models/Host.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HostAlertState model</name>
  <files>Sources/PingScope/Models/HostAlertState.swift</files>
  <action>
Create struct HostAlertState: Sendable with:
- wasDown: Bool = false (for noResponse/recovery detection)
- previousLatencyMS: Double? = nil (for degradation detection)
- recentLatencies: [Double] = [] (rolling window for degradation baseline)
- recentFailures: [Date] = [] (for intermittent detection)
- lastAlertTimes: [AlertType: Date] = [:] (for cooldown)

Methods:
- mutating func recordLatency(_ ms: Double, maxWindowSize: Int = 20)
  Appends to recentLatencies, trims to maxWindowSize
  Updates previousLatencyMS to average of window

- mutating func recordFailure()
  Appends Date() to recentFailures, trims old entries (>60s)

- func canSendAlert(_ alertType: AlertType, cooldown: TimeInterval) -> Bool
  Returns true if no lastAlertTimes entry or time elapsed > cooldown

- mutating func recordAlertSent(_ alertType: AlertType)
  Sets lastAlertTimes[alertType] = Date()

- func failuresInWindow(windowSize: Int) -> Int
  Counts recentFailures entries within last windowSize pings worth of time

- mutating func pruneStaleFailures(maxAge: TimeInterval = 120)
  Removes entries older than maxAge
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>HostAlertState tracks all state needed for alert detection</done>
</task>

<task type="auto">
  <name>Task 2: Create AlertDetector with detection logic</name>
  <files>Sources/PingScope/Services/AlertDetector.swift</files>
  <action>
Create struct AlertDetector: Sendable with:

Static methods (pure functions for testability):

- static func detectNoResponse(
    result: PingResult,
    wasDown: Bool
  ) -> AlertType?
  Returns .noResponse if result.latency == nil AND wasDown == false
  (Transition from up to down)

- static func detectRecovery(
    result: PingResult,
    wasDown: Bool
  ) -> AlertType?
  Returns .recovery if result.latency != nil AND wasDown == true
  (Transition from down to up)

- static func detectHighLatency(
    latencyMS: Double,
    threshold: Double
  ) -> AlertType?
  Returns .highLatency if latencyMS > threshold

- static func detectDegradation(
    currentLatencyMS: Double,
    baselineLatencyMS: Double?,
    degradationPercentage: Double
  ) -> AlertType?
  Returns .degradation if baseline exists AND
  currentLatencyMS > baseline * (1 + degradationPercentage/100)

- static func detectIntermittent(
    failureCount: Int,
    threshold: Int
  ) -> AlertType?
  Returns .intermittent if failureCount >= threshold

- static func detectNetworkChange(
    previousGateway: String?,
    currentGateway: String?
  ) -> AlertType?
  Returns .networkChange if both non-nil AND different

- static func detectInternetLoss(
    allHostResults: [(host: Host, isUp: Bool)]
  ) -> AlertType?
  Returns .internetLoss if all hosts have isUp == false

Main evaluation function:
- static func evaluate(
    result: PingResult,
    host: Host,
    isHostUp: Bool,
    state: inout HostAlertState,
    preferences: NotificationPreferences
  ) -> [AlertType]
  Calls all detection methods, updates state, returns detected alerts
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>AlertDetector has pure detection functions for all 7 alert types</done>
</task>

<task type="auto">
  <name>Task 3: Integrate AlertDetector into NotificationService</name>
  <files>Sources/PingScope/Services/NotificationService.swift</files>
  <action>
Extend NotificationService actor with:

- Private var alertStates: [UUID: HostAlertState] = [:] (per-host tracking)
- Private var previousGatewayIP: String? = nil (for network change)
- Private var lastInternetLossAlert: Date? = nil (cooldown for global alert)

New public methods:

- func evaluateResult(
    _ result: PingResult,
    for host: Host,
    isHostUp: Bool
  ) async
  Gets or creates HostAlertState for host.id
  Calls AlertDetector.evaluate()
  For each detected alert:
    - Check canSendAlert with cooldown
    - Check host override enabled
    - Call sendNotification with appropriate title/body
    - Record alert sent

- func evaluateGatewayChange(from previous: String?, to current: String?) async
  Calls AlertDetector.detectNetworkChange
  If detected and cooldown passed, sends notification

- func evaluateInternetLoss(hostResults: [(Host, Bool)]) async
  Calls AlertDetector.detectInternetLoss
  If detected and cooldown passed, sends notification

Helper to format notification body:
- private func alertBody(for alertType: AlertType, host: Host, latencyMS: Double?) -> String
  Returns human-readable message for each alert type
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>NotificationService integrates AlertDetector and sends appropriate notifications</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `swift build` compiles without errors
2. HostAlertState tracks all required state fields
3. AlertDetector has detection methods for all 7 alert types
4. NotificationService.evaluateResult processes ping results
5. Cooldown logic prevents alert spam
</verification>

<success_criteria>
- All 7 alert types detected: noResponse, highLatency, recovery, degradation, intermittent, networkChange, internetLoss
- Per-host state tracking via HostAlertState
- Cooldown prevents repeated alerts within configured period
- Detection logic is pure/testable in AlertDetector
- NotificationService orchestrates detection and delivery
</success_criteria>

<output>
After completion, create `.planning/phases/06-notifications-settings/06-02-SUMMARY.md`
</output>
