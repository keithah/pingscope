---
phase: 06-notifications-settings
plan: 05
type: execute
wave: 4
depends_on: ["06-04"]
files_modified:
  - Sources/PingScope/App/AppDelegate.swift
  - Sources/PingScope/Resources/PrivacyInfo.xcprivacy
autonomous: true

must_haves:
  truths:
    - "NotificationService is wired into app lifecycle"
    - "Ping results trigger notification evaluation"
    - "Gateway changes trigger network change alerts"
    - "Privacy manifest declares UserDefaults usage"
    - "Notification permission is requested on first launch"
  artifacts:
    - path: "Sources/PingScope/Resources/PrivacyInfo.xcprivacy"
      provides: "App Store privacy manifest"
      contains: "NSPrivacyAccessedAPICategoryUserDefaults"
    - path: "Sources/PingScope/App/AppDelegate.swift"
      provides: "App lifecycle with notification service integration"
      contains: "NotificationService"
  key_links:
    - from: "AppDelegate"
      to: "NotificationService"
      via: "scheduler result callback"
      pattern: "notificationService\\.evaluate"
    - from: "AppDelegate.handleGatewayUpdate"
      to: "NotificationService.evaluateGatewayChange"
      via: "gateway change detection"
      pattern: "evaluateGatewayChange"
---

<objective>
Wire NotificationService into app lifecycle, add privacy manifest for App Store compliance, and ensure notifications work end-to-end.

Purpose: Complete the notification system integration and ensure App Store submission readiness (SETT-04, SETT-05, SETT-06).
Output: Working notification alerts triggered by ping results; privacy manifest for UserDefaults declaration.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notifications-settings/06-RESEARCH.md
@.planning/phases/06-notifications-settings/06-01-SUMMARY.md
@.planning/phases/06-notifications-settings/06-02-SUMMARY.md
@.planning/phases/06-notifications-settings/06-04-SUMMARY.md

# App lifecycle
@Sources/PingScope/App/AppDelegate.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire NotificationService into AppDelegate</name>
  <files>Sources/PingScope/App/AppDelegate.swift</files>
  <action>
Add to AppDelegate properties:
- private let notificationService = NotificationService(
      preferencesStore: NotificationPreferencesStore()
  )
- private var previousGatewayIP: String? = nil

In applicationDidFinishLaunching, after existing setup:
- Request notification permission:
  Task {
      let granted = await notificationService.requestAuthorization()
      if !granted {
          // Optionally log or handle denial
      }
  }

In the scheduler result handler (inside startScheduler):
After existing result processing, add notification evaluation:
```swift
// Evaluate for notifications
let matchedHost = self.monitoredHosts.first {
    $0.address.caseInsensitiveCompare(result.host) == .orderedSame &&
        $0.port == result.port
}
if let host = matchedHost {
    Task {
        await self.notificationService.evaluateResult(result, for: host, isHostUp: isHostUp)
    }
}
```

After processing all results in the callback, evaluate internet loss:
```swift
// Check for internet loss after each result
Task {
    let hostResults = await self.collectHostResults()
    await self.notificationService.evaluateInternetLoss(hostResults: hostResults)
}
```

Add helper method:
```swift
private func collectHostResults() async -> [(Host, Bool)] {
    // Return current up/down state for all monitored hosts
    // This can use the health tracker or track state locally
    monitoredHosts.map { host in
        let isUp = hostListViewModel?.latencies[host.id] != nil
        return (host, isUp)
    }
}
```

In handleGatewayUpdate:
After existing gateway processing:
```swift
if gatewayChanged {
    Task {
        await notificationService.evaluateGatewayChange(
            from: previousGatewayIP,
            to: gatewayInfo.isAvailable ? gatewayInfo.ipAddress : nil
        )
        previousGatewayIP = gatewayInfo.isAvailable ? gatewayInfo.ipAddress : nil
    }
}
```
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>NotificationService integrated into AppDelegate lifecycle</done>
</task>

<task type="auto">
  <name>Task 2: Create Privacy Manifest</name>
  <files>Sources/PingScope/Resources/PrivacyInfo.xcprivacy</files>
  <action>
Create the Resources directory if it doesn't exist.

Create PrivacyInfo.xcprivacy with content:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSPrivacyAccessedAPITypes</key>
    <array>
        <dict>
            <key>NSPrivacyAccessedAPIType</key>
            <string>NSPrivacyAccessedAPICategoryUserDefaults</string>
            <key>NSPrivacyAccessedAPITypeReasons</key>
            <array>
                <string>CA92.1</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
```

The CA92.1 reason code indicates: "Access user defaults to read and write user preferences inside the app."

Note: For Swift Package Manager projects, the privacy manifest needs to be in the resource bundle. Update Package.swift if needed to include resources:
```swift
.target(
    name: "PingScope",
    resources: [.process("Resources")]
)
```
  </action>
  <verify>File exists: `ls -la Sources/PingScope/Resources/PrivacyInfo.xcprivacy`</verify>
  <done>Privacy manifest declares UserDefaults usage with CA92.1 reason</done>
</task>

<task type="auto">
  <name>Task 3: Verify notification flow with build and basic test</name>
  <files>Sources/PingScope/App/AppDelegate.swift</files>
  <action>
Ensure all imports are present in AppDelegate:
- import UserNotifications (if not already imported via NotificationService)

Run full build to verify integration:
`swift build`

Verify the notification service flow:
1. AppDelegate creates NotificationService
2. On launch, requestAuthorization is called
3. Scheduler results flow to evaluateResult
4. Gateway changes flow to evaluateGatewayChange

If needed, add debug logging (can be removed later):
```swift
#if DEBUG
print("[Notifications] Evaluating result for \(host.name): \(result.latency?.description ?? "failed")")
#endif
```

Ensure Package.swift includes resources if privacy manifest was added:
Check for resources: [.process("Resources")] in the target definition.
  </action>
  <verify>Build succeeds: `swift build 2>&1 | tail -5`</verify>
  <done>Notification system fully wired; app builds successfully</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `swift build` compiles without errors
2. AppDelegate creates and uses NotificationService
3. Privacy manifest exists at correct path
4. Notification permission requested on app launch
5. Ping results trigger notification evaluation
6. Gateway changes trigger network change alert evaluation
</verification>

<success_criteria>
- NotificationService wired into AppDelegate
- Permission requested at app launch
- Ping results evaluated for all 7 alert types
- Gateway changes evaluated for network change alerts
- Privacy manifest declares UserDefaults usage
- All settings persist across app restart (via UserDefaults)
</success_criteria>

<output>
After completion, create `.planning/phases/06-notifications-settings/06-05-SUMMARY.md`
</output>
