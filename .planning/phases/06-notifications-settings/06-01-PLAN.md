---
phase: 06-notifications-settings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/PingScope/Models/AlertType.swift
  - Sources/PingScope/Models/NotificationPreferences.swift
  - Sources/PingScope/MenuBar/NotificationPreferencesStore.swift
  - Sources/PingScope/Services/NotificationService.swift
autonomous: true

must_haves:
  truths:
    - "App can request notification permission from user"
    - "Global notification enable/disable toggle works"
    - "Notification preferences persist across app restart"
  artifacts:
    - path: "Sources/PingScope/Models/AlertType.swift"
      provides: "Enum for 7 alert types"
      contains: "enum AlertType"
    - path: "Sources/PingScope/Models/NotificationPreferences.swift"
      provides: "Codable preferences model"
      contains: "struct NotificationPreferences"
    - path: "Sources/PingScope/MenuBar/NotificationPreferencesStore.swift"
      provides: "UserDefaults persistence for notification settings"
      exports: ["NotificationPreferencesStore"]
    - path: "Sources/PingScope/Services/NotificationService.swift"
      provides: "Actor for notification logic and delivery"
      contains: "actor NotificationService"
  key_links:
    - from: "NotificationService"
      to: "UNUserNotificationCenter"
      via: "requestAuthorization and add(request)"
      pattern: "UNUserNotificationCenter\\.current\\(\\)"
    - from: "NotificationPreferencesStore"
      to: "UserDefaults"
      via: "JSONEncoder/JSONDecoder persistence"
      pattern: "userDefaults\\.(data|set)"
---

<objective>
Create the notification foundation: AlertType enum, NotificationPreferences model, NotificationPreferencesStore for persistence, and NotificationService actor for permission handling and notification delivery.

Purpose: Establish the notification subsystem infrastructure that alert detection and settings UI will build upon.
Output: Working notification permission request and delivery capability with persisted global settings.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notifications-settings/06-RESEARCH.md

# Existing patterns to follow
@Sources/PingScope/MenuBar/DisplayPreferencesStore.swift
@Sources/PingScope/Services/HostStore.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AlertType enum and NotificationPreferences model</name>
  <files>Sources/PingScope/Models/AlertType.swift, Sources/PingScope/Models/NotificationPreferences.swift</files>
  <action>
Create AlertType.swift with enum AlertType: String, Codable, CaseIterable, Sendable:
- noResponse (NOTF-02)
- highLatency (NOTF-03)
- recovery (NOTF-04)
- degradation (NOTF-05)
- intermittent (NOTF-06)
- networkChange (NOTF-07)
- internetLoss (NOTF-08)

Add computed property `displayName` returning user-friendly strings.

Create NotificationPreferences.swift with struct NotificationPreferences: Codable, Sendable:
- globalEnabled: Bool = true
- cooldownSeconds: TimeInterval = 60
- enabledAlertTypes: Set<AlertType> = Set(AlertType.allCases)
- highLatencyThresholdMS: Double = 200 (for NOTF-03)
- degradationPercentage: Double = 50 (for NOTF-05: alert if latency increases 50%)
- intermittentFailureCount: Int = 3 (for NOTF-06)
- intermittentWindowSize: Int = 10 (for NOTF-06)

Create HostNotificationOverride: Codable, Sendable for per-host settings:
- hostID: UUID
- enabled: Bool = true
- enabledAlertTypes: Set<AlertType>?  (nil = use global)
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>AlertType enum has 7 cases; NotificationPreferences has all configuration fields</done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationPreferencesStore</name>
  <files>Sources/PingScope/MenuBar/NotificationPreferencesStore.swift</files>
  <action>
Create NotificationPreferencesStore following DisplayPreferencesStore pattern:
- Private userDefaults, key = "notifications.preferences"
- JSONEncoder/JSONDecoder for Codable persistence
- loadPreferences() -> NotificationPreferences
- savePreferences(_ preferences: NotificationPreferences)
- Convenience computed properties:
  - globalEnabled: Bool (get/set)
  - cooldownSeconds: TimeInterval (get/set)
- updatePreferences(_ transform: (inout NotificationPreferences) -> Void)
- hostOverride(for hostID: UUID) -> HostNotificationOverride?
- setHostOverride(_ override: HostNotificationOverride)
- removeHostOverride(for hostID: UUID)

Do NOT mark as actor - keep as final class like DisplayPreferencesStore for synchronous access from SwiftUI bindings.
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>NotificationPreferencesStore loads/saves preferences; supports per-host overrides</done>
</task>

<task type="auto">
  <name>Task 3: Create NotificationService actor</name>
  <files>Sources/PingScope/Services/NotificationService.swift</files>
  <action>
Create actor NotificationService with:
- Private let center = UNUserNotificationCenter.current()
- Private var preferencesStore: NotificationPreferencesStore (injected)
- Private var authorizationStatus: UNAuthorizationStatus = .notDetermined

Public methods:
- requestAuthorization() async -> Bool
  Uses center.requestAuthorization(options: [.alert, .sound])
  Updates authorizationStatus from center.notificationSettings()

- checkAuthorizationStatus() async -> UNAuthorizationStatus
  Returns cached status after refreshing from notificationSettings()

- isAuthorized: Bool (computed, checks status == .authorized)

- sendNotification(title: String, body: String, identifier: String, for alertType: AlertType) async throws
  Guard globalEnabled and alertType in enabledAlertTypes
  Create UNMutableNotificationContent with title, body, sound = .default
  Create UNTimeIntervalNotificationTrigger with timeInterval: 0.1, repeats: false
  Create UNNotificationRequest and add to center

- removeDeliveredNotification(identifier: String) async
  Calls center.removeDeliveredNotifications(withIdentifiers:)

Import UserNotifications framework.
  </action>
  <verify>Build succeeds: `swift build 2>&1 | head -20`</verify>
  <done>NotificationService can request permission and send notifications through UNUserNotificationCenter</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `swift build` compiles without errors
2. AlertType has 7 cases matching NOTF-02 through NOTF-08
3. NotificationPreferences is Codable and Sendable
4. NotificationPreferencesStore persists to UserDefaults
5. NotificationService uses async/await for UNUserNotificationCenter APIs
</verification>

<success_criteria>
- AlertType enum with 7 alert types exists
- NotificationPreferences model with all configurable thresholds exists
- NotificationPreferencesStore persists preferences via UserDefaults
- NotificationService actor can request authorization and send notifications
- All types are Sendable for actor isolation
</success_criteria>

<output>
After completion, create `.planning/phases/06-notifications-settings/06-01-SUMMARY.md`
</output>
