---
phase: 11-11
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/PingScope/Services/ConnectionWrapper.swift
  - Sources/PingScope/Services/PingService.swift
  - Tests/PingScopeTests/PingServiceTests.swift
autonomous: true

must_haves:
  truths:
    - "TCP/UDP connection attempts are tracked and cleaned up through the active ping path"
    - "Cancelling or timing out a ping does not leave stale tracked connections behind"
  artifacts:
    - path: "Sources/PingScope/Services/ConnectionWrapper.swift"
      provides: "Connection lifecycle registration/unregistration hooks"
      contains: "register"
    - path: "Sources/PingScope/Services/PingService.swift"
      provides: "Production wiring between ping execution and ConnectionSweeper"
      contains: "ConnectionSweeper"
    - path: "Tests/PingScopeTests/PingServiceTests.swift"
      provides: "Regression coverage for lifecycle cleanup behavior"
      contains: "sweeper"
  key_links:
    - from: "Sources/PingScope/Services/PingService.swift"
      to: "Sources/PingScope/Services/ConnectionWrapper.swift"
      via: "injected lifecycle tracker"
      pattern: "ConnectionWrapper\("
    - from: "Sources/PingScope/Services/ConnectionWrapper.swift"
      to: "Sources/PingScope/Services/ConnectionSweeper.swift"
      via: "register/unregister around terminal states"
      pattern: "unregister"
---

<objective>
Wire `ConnectionSweeper` into the active TCP/UDP ping lifecycle so the cleanup service is no longer orphaned.

Purpose: Close the v1.0 debt item where sweeper logic existed but was not connected to production ping execution.
Output: Ping runtime registers live network connections, unregisters them on terminal states, and preserves existing ping behavior.
</objective>

<execution_context>
@/Users/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/v1.0-v1.0-MILESTONE-AUDIT.md
@.planning/phases/11-11/11-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

@Sources/PingScope/Services/ConnectionSweeper.swift
@Sources/PingScope/Services/ConnectionWrapper.swift
@Sources/PingScope/Services/PingService.swift
@Tests/PingScopeTests/PingServiceTests.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lifecycle tracking seam to ConnectionWrapper</name>
  <files>Sources/PingScope/Services/ConnectionWrapper.swift</files>
  <action>Introduce a narrow lifecycle tracking interface that lets `ConnectionWrapper` register a newly created `NWConnection` and guarantee unregister on all terminal paths (`ready`, `failed`, `waiting`, `cancelled`, and task cancellation). Ensure unregister happens exactly once per tracked connection, even when multiple terminal callbacks race. Keep connection measurement behavior and error mapping unchanged.</action>
  <verify>`swift build --build-tests` completes with no new errors.</verify>
  <done>`ConnectionWrapper` compiles with lifecycle registration + guaranteed unregister semantics across all exit paths.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ConnectionSweeper through PingService runtime</name>
  <files>Sources/PingScope/Services/PingService.swift</files>
  <action>Give `PingService` a production `ConnectionSweeper` instance and pass it into `ConnectionWrapper` so live TCP/UDP pings use tracking automatically. Start sweeping when the service starts using its default cadence, and avoid changing ICMP behavior. Keep actor isolation intact and avoid introducing global singletons.</action>
  <verify>`swift build --build-tests` completes; app code path still compiles for TCP/UDP/ICMP.</verify>
  <done>Production `PingService` path now uses `ConnectionSweeper` for TCP/UDP lifecycle cleanup.</done>
</task>

<task type="auto">
  <name>Task 3: Add regression coverage for cleanup wiring</name>
  <files>Tests/PingScopeTests/PingServiceTests.swift</files>
  <action>Add/adjust tests to assert lifecycle cleanup is exercised by ping operations (success and non-success outcomes). Use deterministic assertions that avoid flaky timing assumptions. Prefer injected doubles where needed rather than relying on wall-clock sweeper cadence.</action>
  <verify>`swift test --filter PingServiceTests` passes.</verify>
  <done>Tests demonstrate that tracked connections are unregistered after ping completion/cancellation paths.</done>
</task>

</tasks>

<verification>
- `swift build --build-tests`
- `swift test --filter PingServiceTests`
</verification>

<success_criteria>
1. `ConnectionSweeper` is invoked by production TCP/UDP ping path (not just standalone tests).
2. Connection registration/unregistration lifecycle is deterministic and covered by tests.
3. Existing ping result semantics remain unchanged for callers.
</success_criteria>

<output>
After completion, create `.planning/phases/11-11/11-01-SUMMARY.md`
</output>
