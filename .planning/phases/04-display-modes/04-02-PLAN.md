---
phase: 04-display-modes
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - Sources/PingMonitor/ViewModels/DisplayViewModel.swift
  - Sources/PingMonitor/Views/DisplayGraphView.swift
  - Sources/PingMonitor/Views/RecentResultsListView.swift
  - Sources/PingMonitor/Views/FullModeView.swift
  - Sources/PingMonitor/Views/CompactModeView.swift
  - Tests/PingMonitorTests/DisplayViewModelTests.swift
autonomous: true

must_haves:
  truths:
    - "Full mode renders host pills with graph and recent results"
    - "Compact mode renders host dropdown with condensed graph and recent results"
    - "Selected host and selected time range remain stable when switching display mode"
    - "Full and compact remember panel visibility independently"
  artifacts:
    - path: "Sources/PingMonitor/ViewModels/DisplayViewModel.swift"
      provides: "Shared + per-mode UI state and display data projection"
      contains: "selectedHostID|selectedTimeRange"
    - path: "Sources/PingMonitor/Views/FullModeView.swift"
      provides: "450x500 full composition with host pills and collapsible sections"
      contains: "Hosts|Graph|Recent Results"
    - path: "Sources/PingMonitor/Views/CompactModeView.swift"
      provides: "280x220 compact composition with dropdown and condensed stack"
      contains: "Picker"
  key_links:
    - from: "Sources/PingMonitor/ViewModels/DisplayViewModel.swift"
      to: "Sources/PingMonitor/MenuBar/DisplayPreferencesStore.swift"
      via: "load/save shared and per-mode state"
      pattern: "DisplayPreferencesStore"
    - from: "Sources/PingMonitor/Views/CompactModeView.swift"
      to: "Sources/PingMonitor/Views/RecentResultsListView.swift"
      via: "compact recent results list with six-row visible budget"
      pattern: "6|six"
---

<objective>
Build the two mode-specific content surfaces and the state model they share.

Purpose: This delivers DISP-01 and DISP-02 UI composition while enforcing locked behavior for host selector style, panel defaults, and per-mode memory.

Output: Full and compact SwiftUI views backed by a display-focused view model and regression tests.
</objective>

<execution_context>
@/Users/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-display-modes/04-CONTEXT.md
@.planning/phases/04-display-modes/04-RESEARCH.md
@.planning/phases/04-display-modes/04-01-SUMMARY.md

@Sources/PingMonitor/Views/StatusPopoverView.swift
@Sources/PingMonitor/ViewModels/StatusPopoverViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DisplayViewModel with shared/per-mode memory boundaries</name>
  <files>
    Sources/PingMonitor/ViewModels/DisplayViewModel.swift
  </files>
  <action>
Create a dedicated view model for display-mode content:

- Keep shared state (`selectedHostID`, `selectedTimeRange`) in one place used by both modes.
- Keep panel visibility state per mode (`full`, `compact`) and persist changes through `DisplayPreferencesStore`.
- Track recent ping samples per host in a bounded in-memory buffer sufficient for Phase 4 graph/history rendering.
- Expose projected graph points and recent rows for the currently selected host without adding Phase 5 statistics logic.
  </action>
  <verify>`swift build` succeeds and `DisplayViewModel` compiles with no unresolved dependencies.</verify>
  <done>One view model can power both full and compact surfaces while preserving shared context and per-mode visibility memory.</done>
</task>

<task type="auto">
  <name>Task 2: Build full and compact mode SwiftUI compositions</name>
  <files>
    Sources/PingMonitor/Views/DisplayGraphView.swift
    Sources/PingMonitor/Views/RecentResultsListView.swift
    Sources/PingMonitor/Views/FullModeView.swift
    Sources/PingMonitor/Views/CompactModeView.swift
  </files>
  <action>
Implement mode-specific UI shells using `images/` references as composition baseline:

- `FullModeView`: target full layout, top host pills, graph + recent results, independent collapse controls for graph/history.
- `CompactModeView`: target compact layout, top dropdown host selector, graph + recent results with six visible rows before scroll.
- Add lightweight reusable graph/history subviews that render real data from `DisplayViewModel`.
- Keep interactions deterministic and scoped to display behavior; do not implement full visualization controls from Phase 5.
  </action>
  <verify>`swift build` succeeds and previews (if present) compile for both mode views.</verify>
  <done>Both display modes render with required selector style and content stack, matching locked phase constraints.</done>
</task>

<task type="auto">
  <name>Task 3: Add display view-model regression tests</name>
  <files>
    Tests/PingMonitorTests/DisplayViewModelTests.swift
  </files>
  <action>
Add tests covering the mode-switch invariants:

- Switching mode does not reset selected host.
- Switching mode does not reset selected time range.
- Full and compact panel visibility changes remain isolated per mode.
- Recent result projection respects ordering and bounded list behavior used by compact six-row display.
  </action>
  <verify>`swift test --filter DisplayViewModelTests` passes.</verify>
  <done>Core mode-switch and memory behaviors are protected by automated tests.</done>
</task>

</tasks>

<verification>
- `swift build`
- `swift test --filter DisplayViewModelTests`
</verification>

<success_criteria>
- DISP-01 full content composition exists with host pills + graph + history
- DISP-02 compact composition exists with dropdown + condensed graph/history
- Shared context survives mode toggles while panel visibility remains per-mode
</success_criteria>

<output>
After completion, create `.planning/phases/04-display-modes/04-02-SUMMARY.md`
</output>
