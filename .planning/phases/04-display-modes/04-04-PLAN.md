---
phase: 04-display-modes
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - Sources/PingMonitor/App/AppDelegate.swift
  - Sources/PingMonitor/MenuBar/MenuBarRuntime.swift
  - Sources/PingMonitor/PingMonitorApp.swift
  - Sources/PingMonitor/Views/DisplayRootView.swift
  - Tests/PingMonitorTests/MenuBarIntegrationSmokeTests.swift
autonomous: true

must_haves:
  truths:
    - "User can switch between full and compact modes from quick toggle and settings"
    - "Mode switching preserves selected host and time range"
    - "Display opens using popover or floating shell according to stay-on-top setting"
    - "Closing and reopening while stay-on-top is enabled reopens floating"
  artifacts:
    - path: "Sources/PingMonitor/Views/DisplayRootView.swift"
      provides: "Mode-aware root surface that chooses FullModeView or CompactModeView"
      contains: "switch"
    - path: "Sources/PingMonitor/App/AppDelegate.swift"
      provides: "Runtime integration for coordinator, view model, and presentation lifecycle"
      contains: "DisplayModeCoordinator|DisplayViewModel"
    - path: "Sources/PingMonitor/PingMonitorApp.swift"
      provides: "Interim settings controls for display-mode toggles"
      contains: "Compact Mode|Stay on Top"
  key_links:
    - from: "Sources/PingMonitor/App/AppDelegate.swift"
      to: "Sources/PingMonitor/MenuBar/DisplayModeCoordinator.swift"
      via: "status item open/close and mode-switch re-anchor"
      pattern: "open|reanchor|toggle"
    - from: "Sources/PingMonitor/MenuBar/MenuBarRuntime.swift"
      to: "Sources/PingMonitor/ViewModels/DisplayViewModel.swift"
      via: "selection and result fanout"
      pattern: "selectedHostID|ingest"
---

<objective>
Wire display-mode views and presentation coordinator into the running app, including settings and quick-toggle paths.

Purpose: This is the end-to-end integration step that turns the Phase 4 building blocks into actual user-facing behavior for DISP-01 through DISP-06.

Output: App-level display mode routing, settings-based mode controls, and integration smoke coverage.
</objective>

<execution_context>
@/Users/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-display-modes/04-CONTEXT.md
@.planning/phases/04-display-modes/04-RESEARCH.md
@.planning/phases/04-display-modes/04-02-SUMMARY.md
@.planning/phases/04-display-modes/04-03-SUMMARY.md

@Sources/PingMonitor/App/AppDelegate.swift
@Sources/PingMonitor/MenuBar/MenuBarRuntime.swift
@Sources/PingMonitor/PingMonitorApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate DisplayRootView and coordinator into AppDelegate runtime flow</name>
  <files>
    Sources/PingMonitor/App/AppDelegate.swift
    Sources/PingMonitor/MenuBar/MenuBarRuntime.swift
    Sources/PingMonitor/Views/DisplayRootView.swift
  </files>
  <action>
Perform end-to-end runtime wiring:

- Instantiate `DisplayPreferencesStore`, `DisplayViewModel`, and `DisplayModeCoordinator` in app lifecycle.
- Replace fixed popover content with mode-aware root content that renders full or compact surface.
- Fan scheduler results into `DisplayViewModel` for selected-host graph/history data while preserving existing menu bar behavior.
- Ensure mode switches preserve selected host/time range and re-anchor near status item.
- Respect per-mode size and panel visibility restoration on open.
  </action>
  <verify>`swift build` succeeds and app launches with mode-aware content surfaces.</verify>
  <done>App runtime opens correct surface in correct shell and preserves shared state across mode switches.</done>
</task>

<task type="auto">
  <name>Task 2: Expose display toggles in settings while keeping quick toggle behavior</name>
  <files>
    Sources/PingMonitor/PingMonitorApp.swift
    Sources/PingMonitor/MenuBar/MenuBarRuntime.swift
  </files>
  <action>
Implement interim settings controls for Phase 4 (not Phase 6 full settings):

- Replace settings placeholder content with a lightweight display section containing Compact Mode and Stay on Top toggles.
- Bind settings toggles to the same persisted preference keys used by quick toggles.
- Ensure quick toggle path remains available in context menu and both control surfaces stay in sync at runtime.
- Keep settings scope limited to display-mode controls only.
  </action>
  <verify>`swift build` succeeds and toggling from either settings or context menu updates active mode state.</verify>
  <done>Mode switching is available in both required entry points with one persisted source of truth.</done>
</task>

<task type="auto">
  <name>Task 3: Extend integration smoke tests for display mode and shell switching</name>
  <files>
    Tests/PingMonitorTests/MenuBarIntegrationSmokeTests.swift
  </files>
  <action>
Add/extend integration smoke coverage for Phase 4 wiring:

- Verify compact/full toggle updates runtime mode and persists.
- Verify stay-on-top toggle selects floating-shell path instead of popover path.
- Verify selection context is not reset during mode toggles.
- Keep tests deterministic and focused on wiring contracts, not visual assertions.
  </action>
  <verify>`swift test --filter MenuBarIntegrationSmokeTests` passes.</verify>
  <done>Core integration paths for DISP requirements are regression-protected at runtime wiring level.</done>
</task>

</tasks>

<verification>
- `swift build`
- `swift test --filter MenuBarIntegrationSmokeTests`
- `swift run` launches and mode/shell toggles execute without runtime errors
</verification>

<success_criteria>
- DISP-01 and DISP-02 surfaces are reachable through live app flow
- DISP-03 mode switching works from quick toggle and settings
- DISP-04/05/06 shell behavior is wired into app lifecycle and reopen logic
</success_criteria>

<output>
After completion, create `.planning/phases/04-display-modes/04-04-SUMMARY.md`
</output>
