---
phase: 01-foundation
plan: 04
type: tdd
wave: 4
depends_on: ["01-02", "01-03"]
files_modified:
  - Tests/PingMonitorTests/PingServiceTests.swift
  - Tests/PingMonitorTests/HostHealthTrackerTests.swift
  - Tests/PingMonitorTests/ConnectionSweeperTests.swift
autonomous: true

must_haves:
  truths:
    - "Tests verify timeout fires at deadline (not early, not late)"
    - "Tests verify concurrent pings respect max limit"
    - "Tests verify 3-consecutive-failure rule"
    - "Tests verify orphan connection cleanup"
  artifacts:
    - path: "Tests/PingMonitorTests/PingServiceTests.swift"
      provides: "PingService unit tests"
      contains: "func testTimeout"
    - path: "Tests/PingMonitorTests/HostHealthTrackerTests.swift"
      provides: "HostHealthTracker unit tests"
      contains: "func testConsecutiveFailures"
    - path: "Tests/PingMonitorTests/ConnectionSweeperTests.swift"
      provides: "ConnectionSweeper unit tests"
      contains: "func testSweep"
  key_links:
    - from: "PingServiceTests.swift"
      to: "PingService.swift"
      via: "actor instantiation"
      pattern: "PingService\\(\\)"
    - from: "HostHealthTrackerTests.swift"
      to: "HostHealthTracker.swift"
      via: "threshold verification"
      pattern: "recordResult.*success.*false"
---

<objective>
Create unit tests that verify the critical behaviors of the foundation services.

Purpose: Phase 1 success criteria requires unit tests verifying timeout behavior and concurrent ping handling. These tests validate the async patterns work correctly - particularly the timeout racing and consecutive failure tracking that prevent the race conditions from the previous implementation.

Output: Passing test suite that validates core foundation behaviors.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PingService Tests</name>
  <files>
    - Tests/PingMonitorTests/PingServiceTests.swift
  </files>
  <action>
Create tests for PingService focusing on timeout behavior and concurrent handling.

Note: These are integration-style tests that use real network connections. Use well-known hosts (Google DNS, Cloudflare) for reliability. Keep timeouts reasonable for CI.

```swift
import XCTest
@testable import PingMonitor

final class PingServiceTests: XCTestCase {
    var pingService: PingService!

    override func setUp() async throws {
        pingService = PingService()
    }

    // MARK: - Timeout Tests

    func testSuccessfulPing() async {
        // Ping a reliable host
        let result = await pingService.ping(
            address: "8.8.8.8",
            port: 443,
            protocolType: .tcp,
            timeout: .seconds(5)
        )

        XCTAssertTrue(result.isSuccess, "Should successfully ping Google DNS")
        XCTAssertNotNil(result.latency, "Should have latency measurement")
        XCTAssertNil(result.error, "Should have no error")
        XCTAssertGreaterThan(result.latency!, .zero, "Latency should be positive")
    }

    func testTimeoutOnUnreachableHost() async {
        // Use a non-routable IP that will timeout
        let shortTimeout: Duration = .milliseconds(500)
        let startTime = ContinuousClock.now

        let result = await pingService.ping(
            address: "192.0.2.1",  // TEST-NET-1, non-routable
            port: 12345,
            protocolType: .tcp,
            timeout: shortTimeout
        )

        let elapsed = ContinuousClock.now - startTime

        XCTAssertFalse(result.isSuccess, "Should fail on unreachable host")
        XCTAssertTrue(result.isTimeout, "Should be timeout error")

        // Verify timeout fired at approximately the right time (within 200ms tolerance)
        XCTAssertLessThan(elapsed, shortTimeout + .milliseconds(200), "Timeout should fire near deadline")
    }

    func testTimeoutDoesNotFireEarly() async {
        // Ensure timeout doesn't fire before deadline
        let timeout: Duration = .milliseconds(300)
        let startTime = ContinuousClock.now

        _ = await pingService.ping(
            address: "192.0.2.1",  // Will timeout
            port: 12345,
            protocolType: .tcp,
            timeout: timeout
        )

        let elapsed = ContinuousClock.now - startTime

        // Should not return before timeout (with small tolerance for task scheduling)
        XCTAssertGreaterThan(elapsed, timeout - .milliseconds(50), "Should not return before timeout")
    }

    func testInvalidHostError() async {
        let result = await pingService.ping(
            address: "",
            port: 443,
            protocolType: .tcp,
            timeout: .seconds(1)
        )

        XCTAssertFalse(result.isSuccess, "Empty host should fail")
        XCTAssertNotNil(result.error, "Should have error")
    }

    // MARK: - Concurrent Ping Tests

    func testConcurrentPingsRespectLimit() async {
        // Create more hosts than max concurrent (10)
        let hosts = (0..<15).map { i in
            Host(
                id: UUID(),
                name: "Host \(i)",
                address: "8.8.8.8",  // All same host to test concurrency, not network
                port: 443,
                protocolType: .tcp,
                timeout: .seconds(3),
                isDefault: false
            )
        }

        let results = await pingService.pingAll(hosts: hosts, maxConcurrent: 10)

        XCTAssertEqual(results.count, hosts.count, "Should return result for each host")
        // All should succeed (same reliable host)
        XCTAssertTrue(results.allSatisfy { $0.isSuccess }, "All pings should succeed")
    }

    func testResultsReturnedInOrder() async {
        let hosts = [
            Host(id: UUID(), name: "Google", address: "8.8.8.8", port: 443, protocolType: .tcp, timeout: .seconds(3), isDefault: true),
            Host(id: UUID(), name: "Cloudflare", address: "1.1.1.1", port: 443, protocolType: .tcp, timeout: .seconds(3), isDefault: true),
        ]

        let results = await pingService.pingAll(hosts: hosts)

        XCTAssertEqual(results.count, 2)
        XCTAssertEqual(results[0].host, "8.8.8.8", "First result should be first host")
        XCTAssertEqual(results[1].host, "1.1.1.1", "Second result should be second host")
    }

    // MARK: - UDP Tests

    func testUDPPing() async {
        // UDP to DNS port
        let result = await pingService.ping(
            address: "8.8.8.8",
            port: 53,
            protocolType: .udp,
            timeout: .seconds(3)
        )

        // Note: UDP "connection" may succeed immediately in NWConnection
        // The test verifies UDP path doesn't crash, not actual network latency
        XCTAssertNotNil(result, "UDP ping should return result")
    }
}
```

Key test patterns:
- Use async test methods (Swift Testing style)
- Use real network for integration confidence
- Test timeout timing with tolerance for scheduling variance
- Verify results order in pingAll
  </action>
  <verify>
Run `swift test --filter PingServiceTests` - tests should compile and run.
At least 5 tests should exist.
Network tests may fail if offline - that's expected.
  </verify>
  <done>
PingServiceTests.swift exists with tests for: successful ping, timeout on unreachable host, timeout not firing early, invalid host error, concurrent ping limit, results order, UDP ping. Tests use real network connections to Google/Cloudflare DNS.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HostHealthTracker and ConnectionSweeper Tests</name>
  <files>
    - Tests/PingMonitorTests/HostHealthTrackerTests.swift
    - Tests/PingMonitorTests/ConnectionSweeperTests.swift
  </files>
  <action>
Create tests for HostHealthTracker (consecutive failure logic) and ConnectionSweeper (orphan cleanup).

These are pure unit tests - no network needed.

**HostHealthTrackerTests.swift:**
```swift
import XCTest
@testable import PingMonitor

final class HostHealthTrackerTests: XCTestCase {
    var tracker: HostHealthTracker!

    override func setUp() async throws {
        tracker = HostHealthTracker(failureThreshold: 3)
    }

    func testSuccessKeepsHostUp() async {
        let isUp = await tracker.recordResult(host: "test", success: true)
        XCTAssertTrue(isUp, "Success should keep host up")
    }

    func testSingleFailureKeepsHostUp() async {
        let isUp = await tracker.recordResult(host: "test", success: false)
        XCTAssertTrue(isUp, "Single failure should not mark host down")
    }

    func testTwoFailuresKeepsHostUp() async {
        _ = await tracker.recordResult(host: "test", success: false)
        let isUp = await tracker.recordResult(host: "test", success: false)
        XCTAssertTrue(isUp, "Two failures should not mark host down")
    }

    func testThreeFailuresMarksHostDown() async {
        _ = await tracker.recordResult(host: "test", success: false)
        _ = await tracker.recordResult(host: "test", success: false)
        let isUp = await tracker.recordResult(host: "test", success: false)
        XCTAssertFalse(isUp, "Three consecutive failures should mark host down")
    }

    func testSuccessResetsFailureCount() async {
        // Two failures
        _ = await tracker.recordResult(host: "test", success: false)
        _ = await tracker.recordResult(host: "test", success: false)

        // One success resets
        _ = await tracker.recordResult(host: "test", success: true)

        // Two more failures - should still be up
        _ = await tracker.recordResult(host: "test", success: false)
        let isUp = await tracker.recordResult(host: "test", success: false)

        XCTAssertTrue(isUp, "Success should reset failure count")
    }

    func testIsHostDownAfterThreshold() async {
        _ = await tracker.recordResult(host: "test", success: false)
        _ = await tracker.recordResult(host: "test", success: false)
        _ = await tracker.recordResult(host: "test", success: false)

        let isDown = await tracker.isHostDown("test")
        XCTAssertTrue(isDown, "isHostDown should return true after threshold")
    }

    func testResetClearsFailures() async {
        _ = await tracker.recordResult(host: "test", success: false)
        _ = await tracker.recordResult(host: "test", success: false)
        await tracker.reset(host: "test")

        let count = await tracker.failureCount(for: "test")
        XCTAssertEqual(count, 0, "Reset should clear failure count")
    }

    func testIndependentHostTracking() async {
        // Host A fails twice
        _ = await tracker.recordResult(host: "hostA", success: false)
        _ = await tracker.recordResult(host: "hostA", success: false)

        // Host B fails once
        _ = await tracker.recordResult(host: "hostB", success: false)

        // Host A fails third time - should be down
        let hostAUp = await tracker.recordResult(host: "hostA", success: false)

        // Host B should still be up
        let hostBDown = await tracker.isHostDown("hostB")

        XCTAssertFalse(hostAUp, "Host A should be down")
        XCTAssertFalse(hostBDown, "Host B should not be down")
    }
}
```

**ConnectionSweeperTests.swift:**
```swift
import XCTest
import Network
@testable import PingMonitor

final class ConnectionSweeperTests: XCTestCase {
    var sweeper: ConnectionSweeper!

    override func setUp() async throws {
        // Short intervals for testing
        sweeper = ConnectionSweeper(sweepInterval: .milliseconds(100), maxAge: .milliseconds(200))
    }

    override func tearDown() async throws {
        await sweeper.stopSweeping()
        await sweeper.cancelAll()
    }

    func testRegisterIncrementsCount() async {
        let connection = NWConnection(
            host: "8.8.8.8",
            port: 443,
            using: .tcp
        )

        _ = await sweeper.register(connection)
        let count = await sweeper.activeCount

        XCTAssertEqual(count, 1, "Should have one active connection")

        // Cleanup
        connection.cancel()
    }

    func testUnregisterDecrementsCount() async {
        let connection = NWConnection(
            host: "8.8.8.8",
            port: 443,
            using: .tcp
        )

        let id = await sweeper.register(connection)
        await sweeper.unregister(id)
        let count = await sweeper.activeCount

        XCTAssertEqual(count, 0, "Should have no active connections after unregister")

        connection.cancel()
    }

    func testSweepCancelsOldConnections() async {
        let connection = NWConnection(
            host: "8.8.8.8",
            port: 443,
            using: .tcp
        )

        _ = await sweeper.register(connection)

        // Wait for connection to age past maxAge (200ms)
        try? await Task.sleep(for: .milliseconds(250))

        await sweeper.sweep()
        let count = await sweeper.activeCount

        XCTAssertEqual(count, 0, "Sweep should remove old connections")
    }

    func testSweepKeepsRecentConnections() async {
        let connection = NWConnection(
            host: "8.8.8.8",
            port: 443,
            using: .tcp
        )

        _ = await sweeper.register(connection)

        // Sweep immediately (connection is fresh)
        await sweeper.sweep()
        let count = await sweeper.activeCount

        XCTAssertEqual(count, 1, "Sweep should keep recent connections")

        // Cleanup
        connection.cancel()
        await sweeper.cancelAll()
    }

    func testCancelAllRemovesEverything() async {
        let conn1 = NWConnection(host: "8.8.8.8", port: 443, using: .tcp)
        let conn2 = NWConnection(host: "1.1.1.1", port: 443, using: .tcp)

        _ = await sweeper.register(conn1)
        _ = await sweeper.register(conn2)

        await sweeper.cancelAll()
        let count = await sweeper.activeCount

        XCTAssertEqual(count, 0, "cancelAll should remove all connections")
    }

    func testAutomaticSweeping() async {
        await sweeper.startSweeping()

        let connection = NWConnection(
            host: "8.8.8.8",
            port: 443,
            using: .tcp
        )

        _ = await sweeper.register(connection)

        // Wait for automatic sweep (100ms interval + 200ms age + buffer)
        try? await Task.sleep(for: .milliseconds(400))

        let count = await sweeper.activeCount
        XCTAssertEqual(count, 0, "Automatic sweeping should clean old connections")
    }
}
```

Key test patterns:
- HostHealthTracker tests are pure logic (no network)
- ConnectionSweeper uses real NWConnection but doesn't start them
- Short sweep intervals for fast tests
- Always cleanup connections in tearDown
  </action>
  <verify>
Run `swift test --filter HostHealthTrackerTests` - should pass.
Run `swift test --filter ConnectionSweeperTests` - should pass.
Verify at least 8 tests for HostHealthTracker.
Verify at least 5 tests for ConnectionSweeper.
  </verify>
  <done>
HostHealthTrackerTests.swift tests: single/double/triple failures, success reset, isHostDown, reset, independent host tracking. ConnectionSweeperTests.swift tests: register/unregister counts, sweep old/keep recent, cancelAll, automatic sweeping. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `swift test` runs all tests
2. PingServiceTests has tests for timeout behavior
3. HostHealthTrackerTests verifies 3-consecutive-failure rule
4. ConnectionSweeperTests verifies orphan cleanup
5. All tests pass (network tests may need real connectivity)
</verification>

<success_criteria>
- Tests verify timeout fires at deadline (not early, not late)
- Tests verify concurrent pings respect max limit (10)
- Tests verify 3-consecutive-failure rule
- Tests verify orphan connection cleanup (sweep removes old)
- Tests verify success resets failure count
- All tests pass with `swift test`
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
