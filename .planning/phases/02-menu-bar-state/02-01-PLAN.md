---
phase: 02-menu-bar-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/PingMonitor/MenuBar/MenuBarState.swift
  - Sources/PingMonitor/MenuBar/MenuBarStatusEvaluator.swift
  - Sources/PingMonitor/MenuBar/LatencySmoother.swift
  - Sources/PingMonitor/ViewModels/MenuBarViewModel.swift
  - Tests/PingMonitorTests/MenuBarViewModelTests.swift
autonomous: true

must_haves:
  truths:
    - "Menu bar state resolves to green/yellow/red/gray according to phase rules"
    - "Menu bar displays compact latency text as '## ms' or 'N/A'"
    - "Displayed latency updates are smoothed to reduce jitter"
  artifacts:
    - path: "Sources/PingMonitor/MenuBar/MenuBarStatusEvaluator.swift"
      provides: "Centralized status color evaluation"
      contains: "enum MenuBarStatus"
    - path: "Sources/PingMonitor/ViewModels/MenuBarViewModel.swift"
      provides: "Main-thread observable state for menu bar UI"
      contains: "@MainActor"
    - path: "Tests/PingMonitorTests/MenuBarViewModelTests.swift"
      provides: "Behavior tests for status/text/smoothing"
      contains: "test"
  key_links:
    - from: "MenuBarViewModel.swift"
      to: "MenuBarStatusEvaluator.swift"
      via: "derive status from ping results and failure streak"
      pattern: "evaluate"
    - from: "MenuBarViewModel.swift"
      to: "LatencySmoother.swift"
      via: "transform raw latency before display text"
      pattern: "smooth|next"
---

<objective>
Create the menu bar state pipeline that converts ping results into a stable, compact status readout.

Purpose: Phase 2 UI interaction depends on reliable menu bar state semantics. This plan establishes centralized status evaluation, compact text formatting, and jitter smoothing so later plans can render and interact without duplicating logic.

Output: A tested `@MainActor` menu bar view model and evaluator stack ready to drive status item rendering.
</objective>

<execution_context>
@/Users/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-menu-bar-state/02-CONTEXT.md
@.planning/phases/02-menu-bar-state/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@Sources/PingMonitor/Services/PingScheduler.swift
@Sources/PingMonitor/Models/PingResult.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement menu bar state and status evaluation primitives</name>
  <files>
    - Sources/PingMonitor/MenuBar/MenuBarState.swift
    - Sources/PingMonitor/MenuBar/MenuBarStatusEvaluator.swift
    - Sources/PingMonitor/MenuBar/LatencySmoother.swift
  </files>
  <action>
Create foundational menu bar domain types:

- `MenuBarStatus` enum (`green`, `yellow`, `red`, `gray`) and UI-facing state struct containing current text, status, and last raw latency.
- `MenuBarStatusEvaluator` that enforces locked color semantics from context:
  - green: healthy latency range
  - yellow: warning latency while responses continue
  - red: sustained failure (not a single miss)
  - gray: startup/no-data or intentionally inactive.
- `LatencySmoother` for display-only smoothing (EMA or bounded-step strategy chosen by implementer), preserving raw latency values separately.

Avoid scattering thresholds and status logic across UI components; keep all transitions centralized in evaluator.
  </action>
  <verify>
Run `swift build` and confirm new menu bar types compile.
Run `swift test --filter MenuBarViewModelTests` after Task 2 adds tests.
  </verify>
  <done>
Menu bar status and text derivation primitives exist as standalone files; evaluator encodes sustained-failure red behavior and gray startup behavior; smoothing utility is reusable and side-effect free.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build @MainActor menu bar view model with behavior tests</name>
  <files>
    - Sources/PingMonitor/ViewModels/MenuBarViewModel.swift
    - Tests/PingMonitorTests/MenuBarViewModelTests.swift
  </files>
  <action>
Implement `MenuBarViewModel` as the single source of truth for menu display state.

- Expose observable properties for compact text (`## ms` or `N/A`), status color enum, selected host summary, and mode flags needed by context menu.
- Add methods to ingest `PingResult` updates from scheduler callbacks and update state on main actor only.
- Integrate evaluator and smoother so raw latency and display latency are separated.
- Include tests for: startup gray + `N/A`, healthy/warning transitions, sustained-failure-to-red rule, and smoothing behavior that reduces abrupt text jumps.

Do not couple this view model directly to `NSStatusItem` classes in this plan.
  </action>
  <verify>
Run `swift test --filter MenuBarViewModelTests`.
Run `swift test` to ensure no regressions in Phase 1 suites.
  </verify>
  <done>
MenuBarViewModel can be updated from ping results and always emits compact display text plus correct status category; tests cover the locked decision rules.
  </done>
</task>

</tasks>

<verification>
`swift build` and `swift test` pass with new menu bar state and tests.
</verification>

<success_criteria>
- Menu status logic is centralized and deterministic.
- Display text is compact (`## ms` or `N/A`) and smoothing is applied.
- Tests prove sustained-failure behavior before red and startup gray behavior.
</success_criteria>

<output>
After completion, create `.planning/phases/02-menu-bar-state/02-menu-bar-state-01-SUMMARY.md`
</output>
