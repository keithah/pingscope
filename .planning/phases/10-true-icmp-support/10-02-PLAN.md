---
phase: 10-true-icmp-support
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - Sources/PingScope/Services/ICMPPinger.swift
autonomous: true

must_haves:
  truths:
    - "ICMP echo requests can be sent without root privileges"
    - "ICMP echo replies are received and latency measured"
    - "Timeout handling works correctly for ICMP pings"
  artifacts:
    - path: "Sources/PingScope/Services/ICMPPinger.swift"
      provides: "Non-privileged ICMP ping implementation"
      contains: "ICMPPinger"
  key_links:
    - from: "ICMPPinger"
      to: "socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)"
      via: "socket creation"
      pattern: "SOCK_DGRAM.*IPPROTO_ICMP"
    - from: "ICMPPinger.ping"
      to: "withThrowingTaskGroup"
      via: "timeout racing"
      pattern: "withThrowingTaskGroup"
---

<objective>
Implement the ICMPPinger service that sends true ICMP echo requests using non-privileged datagram sockets.

Purpose: This is the core ICMP implementation that enables real ping measurements when running outside the App Store sandbox.
Output: A new ICMPPinger actor that integrates with existing Swift Concurrency patterns and PingError types.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-true-icmp-support/10-RESEARCH.md
@.planning/phases/10-true-icmp-support/10-01-SUMMARY.md

@Sources/PingScope/Utilities/ICMPPacket.swift
@Sources/PingScope/Models/PingError.swift
@Sources/PingScope/Services/PingService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ICMPPinger actor with socket management</name>
  <files>Sources/PingScope/Services/ICMPPinger.swift</files>
  <action>
Create the ICMPPinger actor that implements true ICMP ping using non-privileged datagram sockets.

Key design decisions from RESEARCH.md:
- Use `socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)` - NOT SOCK_RAW (no root required)
- Use withThrowingTaskGroup for timeout racing (matches existing PingService pattern)
- Use withCheckedThrowingContinuation to bridge socket callbacks to async/await
- Generate unique identifier per pinger instance to avoid matching other processes' responses
- Validate ICMP reply identifier matches our request identifier

Implementation:

```swift
import Foundation
import Darwin

/// ICMP pinger using non-privileged datagram sockets.
/// Only works outside App Store sandbox (Developer ID distribution).
/// Uses SOCK_DGRAM + IPPROTO_ICMP which doesn't require root privileges.
actor ICMPPinger {
    private let identifier: UInt16
    private var sequenceNumber: UInt16 = 0

    init() {
        // Generate unique identifier for this pinger instance
        // Use lower 16 bits of process ID for reasonable uniqueness
        self.identifier = UInt16(truncatingIfNeeded: getpid())
    }

    /// Ping a host with ICMP echo request.
    /// - Parameters:
    ///   - host: Hostname or IP address to ping
    ///   - timeout: Maximum time to wait for response
    /// - Returns: Round-trip latency duration
    /// - Throws: PingError on failure
    func ping(host: String, timeout: Duration) async throws -> Duration {
        try await withThrowingTaskGroup(of: Duration.self) { group in
            group.addTask {
                try await self.sendAndReceive(host: host)
            }

            group.addTask {
                try await Task.sleep(for: timeout)
                throw PingError.timeout
            }

            defer { group.cancelAll() }

            guard let result = try await group.next() else {
                throw PingError.cancelled
            }
            return result
        }
    }

    /// Internal send/receive implementation
    private func sendAndReceive(host: String) async throws -> Duration {
        // Resolve hostname to IP address
        let address = try resolveHost(host)

        // Create socket
        let fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)
        guard fd >= 0 else {
            throw PingError.connectionFailed("Failed to create ICMP socket: \(String(cString: strerror(errno)))")
        }
        defer { close(fd) }

        // Disable SIGPIPE
        var noSigPipe: Int32 = 1
        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &noSigPipe, socklen_t(MemoryLayout<Int32>.size))

        // Increment sequence number
        sequenceNumber &+= 1
        let seq = sequenceNumber

        // Build ICMP packet
        let packet = buildEchoRequest(sequenceNumber: seq)

        // Record start time
        let startTime = ContinuousClock.now

        // Send packet
        try sendPacket(fd: fd, packet: packet, to: address)

        // Receive response (blocking, but we're in a task that can be cancelled)
        try await receiveResponse(fd: fd, expectedSequence: seq)

        // Calculate latency
        return ContinuousClock.now - startTime
    }

    /// Resolve hostname to sockaddr_in
    private func resolveHost(_ host: String) throws -> sockaddr_in {
        var hints = addrinfo()
        hints.ai_family = AF_INET
        hints.ai_socktype = SOCK_DGRAM

        var result: UnsafeMutablePointer<addrinfo>?
        let status = getaddrinfo(host, nil, &hints, &result)
        guard status == 0, let addrInfo = result else {
            throw PingError.connectionFailed("Failed to resolve host: \(host)")
        }
        defer { freeaddrinfo(result) }

        // Extract sockaddr_in from result
        guard let sockaddr = addrInfo.pointee.ai_addr else {
            throw PingError.connectionFailed("No address found for host: \(host)")
        }

        return sockaddr.withMemoryRebound(to: sockaddr_in.self, capacity: 1) { $0.pointee }
    }

    /// Build ICMP echo request packet
    private func buildEchoRequest(sequenceNumber: UInt16) -> Data {
        // Create header with zero checksum
        var header = ICMPHeader.echoRequestHeader(identifier: identifier, sequenceNumber: sequenceNumber)

        // Add payload (timestamp for debugging, matches common ping implementations)
        let payload = "PingScope".data(using: .utf8) ?? Data()

        // Serialize header
        var headerData = header.toData()

        // Compute checksum over header + payload
        var fullPacket = headerData + payload
        let checksum = icmpChecksum(data: fullPacket)

        // Insert checksum into packet (bytes 2-3)
        fullPacket[2] = UInt8(checksum >> 8)
        fullPacket[3] = UInt8(checksum & 0xFF)

        return fullPacket
    }

    /// Send ICMP packet to address
    private func sendPacket(fd: Int32, packet: Data, to address: sockaddr_in) throws {
        var addr = address
        let sent = packet.withUnsafeBytes { buffer in
            withUnsafePointer(to: &addr) { addrPtr in
                addrPtr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockaddrPtr in
                    sendto(fd, buffer.baseAddress, buffer.count, 0, sockaddrPtr, socklen_t(MemoryLayout<sockaddr_in>.size))
                }
            }
        }

        guard sent == packet.count else {
            throw PingError.connectionFailed("Failed to send ICMP packet: \(String(cString: strerror(errno)))")
        }
    }

    /// Receive ICMP response asynchronously
    private func receiveResponse(fd: Int32, expectedSequence: UInt16) async throws {
        // Set up non-blocking receive with select
        var readSet = fd_set()
        __darwin_fd_zero(&readSet)
        __darwin_fd_set(fd, &readSet)

        // Use continuation to bridge blocking receive to async
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            // Use dispatch source for async socket reading
            let source = DispatchSource.makeReadSource(fileDescriptor: fd, queue: .global())

            var hasResumed = false

            source.setEventHandler { [self] in
                guard !hasResumed else { return }

                var buffer = [UInt8](repeating: 0, count: 1024)
                var senderAddr = sockaddr_in()
                var addrLen = socklen_t(MemoryLayout<sockaddr_in>.size)

                let received = withUnsafeMutablePointer(to: &senderAddr) { addrPtr in
                    addrPtr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockaddrPtr in
                        recvfrom(fd, &buffer, buffer.count, 0, sockaddrPtr, &addrLen)
                    }
                }

                guard received > 0 else {
                    hasResumed = true
                    source.cancel()
                    continuation.resume(throwing: PingError.connectionFailed("Failed to receive ICMP response"))
                    return
                }

                // Parse ICMP header from response
                // Note: SOCK_DGRAM returns ICMP packet without IP header
                let data = Data(buffer.prefix(received))
                guard let responseHeader = ICMPHeader.from(data: data) else {
                    hasResumed = true
                    source.cancel()
                    continuation.resume(throwing: PingError.connectionFailed("Invalid ICMP response"))
                    return
                }

                // Validate response
                guard responseHeader.type == ICMPHeader.echoReply,
                      responseHeader.identifier == self.identifier,
                      responseHeader.sequenceNumber == expectedSequence else {
                    // Not our packet, keep waiting
                    return
                }

                hasResumed = true
                source.cancel()
                continuation.resume()
            }

            source.setCancelHandler {
                // Ensure we resume if cancelled without receiving
                if !hasResumed {
                    hasResumed = true
                    continuation.resume(throwing: PingError.cancelled)
                }
            }

            source.resume()
        }
    }
}

// MARK: - fd_set helpers for Darwin
private func __darwin_fd_zero(_ set: inout fd_set) {
    set.__fds_bits = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
}

private func __darwin_fd_set(_ fd: Int32, _ set: inout fd_set) {
    let intOffset = Int(fd / 32)
    let bitOffset = Int(fd % 32)
    let mask = Int32(1 << bitOffset)
    withUnsafeMutablePointer(to: &set.__fds_bits) { ptr in
        ptr.withMemoryRebound(to: Int32.self, capacity: 32) { intPtr in
            intPtr[intOffset] |= mask
        }
    }
}
```

Key implementation notes:
1. Uses SOCK_DGRAM (datagram socket) not SOCK_RAW - no root privileges needed
2. Process ID used as identifier to avoid collision with other ping processes
3. Sequence number increments per request for matching responses
4. Uses DispatchSource for async socket reading (bridges to continuation)
5. Validates response identifier and sequence number match our request
6. Timeout racing uses same withThrowingTaskGroup pattern as PingService
7. All socket operations properly clean up on error/cancellation
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`

Manual verification (when running non-sandboxed):
- ICMPPinger can be instantiated
- Calling ping on a known-good host (e.g., 8.8.8.8) returns latency or throws appropriate error
  </verify>
  <done>ICMPPinger actor exists with ping(host:timeout:) method that sends real ICMP echo requests using non-privileged sockets.</done>
</task>

</tasks>

<verification>
- `swift build` compiles without errors
- ICMPPinger imports ICMPHeader and icmpChecksum from 10-01
- No changes to existing files
- Actor isolation is correct (sequenceNumber mutation is safe)
</verification>

<success_criteria>
1. Sources/PingScope/Services/ICMPPinger.swift exists with ping(host:timeout:) method
2. Uses SOCK_DGRAM + IPPROTO_ICMP (not SOCK_RAW)
3. Uses withThrowingTaskGroup for timeout racing (matches PingService pattern)
4. Uses withCheckedThrowingContinuation for async socket I/O
5. Validates response identifier and sequence match request
6. Compiles cleanly with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-true-icmp-support/10-02-SUMMARY.md`
</output>
