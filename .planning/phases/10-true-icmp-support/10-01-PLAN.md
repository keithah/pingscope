---
phase: 10-true-icmp-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/PingScope/Services/SandboxDetector.swift
  - Sources/PingScope/Utilities/ICMPPacket.swift
autonomous: true

must_haves:
  truths:
    - "App can detect sandbox status at runtime"
    - "ICMP packet structures are available for echo request/reply"
  artifacts:
    - path: "Sources/PingScope/Services/SandboxDetector.swift"
      provides: "Runtime sandbox detection"
      contains: "isRunningInSandbox"
    - path: "Sources/PingScope/Utilities/ICMPPacket.swift"
      provides: "ICMP header and checksum calculation"
      contains: "ICMPHeader"
  key_links:
    - from: "SandboxDetector"
      to: "NSHomeDirectory()"
      via: "path check"
      pattern: "Library/Containers"
---

<objective>
Create the foundational utilities for true ICMP support: sandbox detection and ICMP packet structures.

Purpose: Enables runtime detection of sandbox status (App Store vs Developer ID) and provides the ICMP header/checksum primitives needed by ICMPPinger.
Output: Two new utility files that subsequent plans will use for ICMP ping implementation.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-true-icmp-support/10-RESEARCH.md

@Sources/PingScope/Models/PingError.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SandboxDetector utility</name>
  <files>Sources/PingScope/Services/SandboxDetector.swift</files>
  <action>
Create a simple enum with a static property to detect sandbox status at runtime.

Implementation:
```swift
import Foundation

enum SandboxDetector {
    /// Returns true if the app is running in the App Store sandbox.
    /// App Store sandbox places app container in /Library/Containers/.
    static var isRunningInSandbox: Bool {
        NSHomeDirectory().contains("/Library/Containers/")
    }
}
```

This uses the documented approach from Apple Developer Forums - sandboxed apps have their home directory inside /Library/Containers/. This is simple, reliable, and requires no Security framework overhead.

Ensure:
- Conforms to Sendable (enum with static-only members is Sendable by default)
- No external dependencies
- Clear documentation comment explaining the detection mechanism
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`
  </verify>
  <done>SandboxDetector.isRunningInSandbox is callable and returns Bool based on home directory path.</done>
</task>

<task type="auto">
  <name>Task 2: Create ICMPPacket structures</name>
  <files>Sources/PingScope/Utilities/ICMPPacket.swift</files>
  <action>
Create the ICMP packet header structure and internet checksum calculation function needed for ICMP ping.

Create the Utilities directory if it doesn't exist.

Implementation based on macOS icmp(4) man page and RFC 792:

```swift
import Foundation

/// ICMP header structure for echo request/reply packets.
/// Source: macOS icmp(4) man page, RFC 792
struct ICMPHeader {
    var type: UInt8        // 8 = echo request, 0 = echo reply
    var code: UInt8        // Must be 0 for echo
    var checksum: UInt16   // Internet checksum (ones-complement)
    var identifier: UInt16 // Process-unique identifier
    var sequenceNumber: UInt16 // Incremented per request

    static let echoRequest: UInt8 = 8
    static let echoReply: UInt8 = 0

    /// Size of ICMP header in bytes
    static let size: Int = 8
}

/// Calculate internet checksum per RFC 1071.
/// Used for ICMP header checksum calculation.
/// Source: Apple SimplePing, RFC 1071
func icmpChecksum(data: Data) -> UInt16 {
    var sum: UInt32 = 0
    var index = 0

    // Sum 16-bit words (big-endian)
    while index < data.count - 1 {
        let word = UInt32(data[index]) << 8 | UInt32(data[index + 1])
        sum += word
        index += 2
    }

    // Add odd byte if present (padded with zero)
    if index < data.count {
        sum += UInt32(data[index]) << 8
    }

    // Fold 32-bit sum to 16 bits (handle carry)
    while sum >> 16 != 0 {
        sum = (sum & 0xFFFF) + (sum >> 16)
    }

    // Return ones-complement
    return ~UInt16(sum)
}

extension ICMPHeader {
    /// Create an echo request header with the given identifier and sequence.
    /// Checksum is initially zero and must be computed after serialization.
    static func echoRequestHeader(identifier: UInt16, sequenceNumber: UInt16) -> ICMPHeader {
        ICMPHeader(
            type: echoRequest,
            code: 0,
            checksum: 0,  // Computed after serialization
            identifier: identifier,
            sequenceNumber: sequenceNumber
        )
    }

    /// Serialize header to Data for transmission.
    /// All multi-byte fields use network byte order (big-endian).
    func toData() -> Data {
        var data = Data(count: ICMPHeader.size)
        data[0] = type
        data[1] = code
        // Checksum in network byte order
        data[2] = UInt8(checksum >> 8)
        data[3] = UInt8(checksum & 0xFF)
        // Identifier in network byte order
        data[4] = UInt8(identifier >> 8)
        data[5] = UInt8(identifier & 0xFF)
        // Sequence number in network byte order
        data[6] = UInt8(sequenceNumber >> 8)
        data[7] = UInt8(sequenceNumber & 0xFF)
        return data
    }

    /// Parse header from received Data.
    /// Returns nil if data is too short.
    static func from(data: Data) -> ICMPHeader? {
        guard data.count >= ICMPHeader.size else { return nil }
        return ICMPHeader(
            type: data[0],
            code: data[1],
            checksum: UInt16(data[2]) << 8 | UInt16(data[3]),
            identifier: UInt16(data[4]) << 8 | UInt16(data[5]),
            sequenceNumber: UInt16(data[6]) << 8 | UInt16(data[7])
        )
    }
}
```

Key points:
- Use network byte order (big-endian) for all multi-byte fields via manual bit operations (not htons/ntohs which aren't available in pure Swift)
- Checksum uses standard internet checksum algorithm (ones-complement sum)
- Header is exactly 8 bytes per RFC 792
- Include both serialization (toData) and parsing (from) for send/receive
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`

Verify ICMPHeader size: Add temporary test or inspection that ICMPHeader.size == 8
  </verify>
  <done>ICMPHeader struct and icmpChecksum function are available for ICMP packet construction and validation.</done>
</task>

</tasks>

<verification>
- `swift build` compiles without errors
- SandboxDetector.isRunningInSandbox can be called and returns Bool
- ICMPHeader can be created, serialized to Data, and parsed back
- icmpChecksum produces valid ones-complement checksum
</verification>

<success_criteria>
1. Sources/PingScope/Services/SandboxDetector.swift exists with isRunningInSandbox property
2. Sources/PingScope/Utilities/ICMPPacket.swift exists with ICMPHeader and icmpChecksum
3. Both files compile cleanly with no warnings
4. No changes to existing files (pure additions)
</success_criteria>

<output>
After completion, create `.planning/phases/10-true-icmp-support/10-01-SUMMARY.md`
</output>
