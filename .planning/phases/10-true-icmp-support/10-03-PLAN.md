---
phase: 10-true-icmp-support
plan: 03
type: execute
wave: 3
depends_on: ["10-01", "10-02"]
files_modified:
  - Sources/PingScope/Models/PingMethod.swift
  - Sources/PingScope/Services/PingService.swift
  - Sources/PingScope/Views/AddHostSheet.swift
autonomous: true

must_haves:
  truths:
    - "PingMethod.icmp case is available when not sandboxed"
    - "ICMP option is hidden from UI when sandboxed"
    - "PingService routes .icmp to ICMPPinger"
    - "Existing TCP/UDP/icmpSimulated methods work unchanged"
  artifacts:
    - path: "Sources/PingScope/Models/PingMethod.swift"
      provides: "PingMethod.icmp case and availableCases"
      contains: "case icmp"
    - path: "Sources/PingScope/Services/PingService.swift"
      provides: "ICMP routing to ICMPPinger"
      contains: "case .icmp"
    - path: "Sources/PingScope/Views/AddHostSheet.swift"
      provides: "Filtered ping method picker"
      contains: "availableCases"
  key_links:
    - from: "PingMethod.availableCases"
      to: "SandboxDetector.isRunningInSandbox"
      via: "conditional filtering"
      pattern: "SandboxDetector"
    - from: "PingService"
      to: "ICMPPinger"
      via: "case routing"
      pattern: "icmpPinger\\.ping"
    - from: "AddHostSheet"
      to: "PingMethod.availableCases"
      via: "picker data source"
      pattern: "availableCases"
---

<objective>
Integrate ICMP support into existing PingMethod, PingService, and UI components.

Purpose: Wire the new ICMPPinger service into the existing architecture so users can select and use true ICMP ping when running outside the sandbox.
Output: Updated PingMethod with .icmp case, PingService routing, and AddHostSheet filtering based on sandbox status.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-true-icmp-support/10-RESEARCH.md
@.planning/phases/10-true-icmp-support/10-01-SUMMARY.md
@.planning/phases/10-true-icmp-support/10-02-SUMMARY.md

@Sources/PingScope/Models/PingMethod.swift
@Sources/PingScope/Services/PingService.swift
@Sources/PingScope/Services/SandboxDetector.swift
@Sources/PingScope/Services/ICMPPinger.swift
@Sources/PingScope/Views/AddHostSheet.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PingMethod.icmp case with availableCases</name>
  <files>Sources/PingScope/Models/PingMethod.swift</files>
  <action>
Update PingMethod enum to include the new .icmp case and add an availableCases computed property that filters based on sandbox status.

Changes to make:
1. Add `case icmp` to the enum (before or after existing cases, maintain CaseIterable)
2. Add `displayName` for .icmp case: "ICMP"
3. Add `defaultPort` for .icmp case: 0 (ICMP doesn't use ports)
4. Add static `availableCases` computed property that:
   - Returns all cases if NOT sandboxed
   - Returns [.tcp, .udp, .icmpSimulated] if sandboxed (excludes .icmp)

Updated implementation:

```swift
import Foundation

enum PingMethod: String, Sendable, Codable, CaseIterable, Equatable {
    case tcp
    case udp
    case icmpSimulated
    case icmp  // True ICMP - only available outside sandbox

    // ICMP-simulated mode attempts TCP probes in this order.
    static let icmpSimulatedProbePorts: [UInt16] = [53, 80, 443, 22, 25]

    /// Returns the ping methods available in the current runtime environment.
    /// When running in App Store sandbox, true ICMP is not available.
    static var availableCases: [PingMethod] {
        if SandboxDetector.isRunningInSandbox {
            return [.tcp, .udp, .icmpSimulated]
        }
        return allCases
    }

    var displayName: String {
        switch self {
        case .tcp:
            return "TCP"
        case .udp:
            return "UDP"
        case .icmpSimulated:
            return "ICMP (Simulated)"
        case .icmp:
            return "ICMP"
        }
    }

    var defaultPort: UInt16 {
        switch self {
        case .tcp:
            return 80
        case .udp:
            return 53
        case .icmpSimulated:
            return 53
        case .icmp:
            return 0  // ICMP doesn't use ports
        }
    }
}
```

Important: Ensure existing code that uses PingMethod.allCases for iteration still works. The new .icmp case will be included in allCases (CaseIterable), but UI should use availableCases.
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`

Verify enum cases: PingMethod.allCases should contain 4 cases
  </verify>
  <done>PingMethod.icmp exists with displayName "ICMP", defaultPort 0, and availableCases filters based on sandbox.</done>
</task>

<task type="auto">
  <name>Task 2: Route .icmp through ICMPPinger in PingService</name>
  <files>Sources/PingScope/Services/PingService.swift</files>
  <action>
Update PingService to route .icmp pings through the new ICMPPinger service.

Changes to make:
1. Add private property to hold ICMPPinger instance: `private let icmpPinger = ICMPPinger()`
2. Update `ping(host:)` method to handle .icmp case:
   - Route to icmpPinger.ping(host:timeout:)
   - Return success/failure PingResult based on result
3. Update `ping(address:port:pingMethod:timeout:)` method to handle .icmp case:
   - Return failure with appropriate error message (ICMP doesn't use ports)
   - Or alternatively, call icmpPinger ignoring port

The Host-based ping method should be the primary path for ICMP:

```swift
// In ping(host:) method, update switch statement:
switch host.pingMethod {
case .tcp, .udp:
    return await ping(
        address: host.address,
        port: host.port,
        pingMethod: host.pingMethod,
        timeout: effectiveTimeout
    )
case .icmpSimulated:
    return await pingICMPSimulated(host: host, timeout: effectiveTimeout)
case .icmp:
    return await pingICMP(host: host, timeout: effectiveTimeout)
}

// Add new private method:
private func pingICMP(host: Host, timeout: Duration) async -> PingResult {
    do {
        let latency = try await icmpPinger.ping(host: host.address, timeout: timeout)
        return .success(host: host.address, port: 0, latency: latency)
    } catch let error as PingError {
        return .failure(host: host.address, port: 0, error: error)
    } catch is CancellationError {
        return .failure(host: host.address, port: 0, error: .cancelled)
    } catch {
        return .failure(host: host.address, port: 0, error: .connectionFailed(error.localizedDescription))
    }
}
```

Also update the port-based ping overload to reject .icmp:

```swift
// In ping(address:port:pingMethod:timeout:) method, add case:
case .icmp:
    return .failure(
        host: address,
        port: port,
        error: .connectionFailed("Use ping(host:) for ICMP pings")
    )
```

This matches the existing .icmpSimulated error handling pattern.
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`

Verify switch exhaustiveness: All PingMethod cases handled in both switch statements
  </verify>
  <done>PingService routes .icmp to ICMPPinger and returns appropriate PingResult for success/failure.</done>
</task>

<task type="auto">
  <name>Task 3: Filter ping method picker in AddHostSheet</name>
  <files>Sources/PingScope/Views/AddHostSheet.swift</files>
  <action>
Update AddHostSheet to use PingMethod.availableCases instead of PingMethod.allCases in the picker.

Find the Picker for "Ping Method" and change:

FROM:
```swift
Picker("Ping Method", selection: $viewModel.pingMethod) {
    ForEach(PingMethod.allCases, id: \.self) { method in
        Text(method.displayName).tag(method)
    }
}
```

TO:
```swift
Picker("Ping Method", selection: $viewModel.pingMethod) {
    ForEach(PingMethod.availableCases, id: \.self) { method in
        Text(method.displayName).tag(method)
    }
}
```

This single change ensures:
- When sandboxed: Shows TCP, UDP, ICMP (Simulated)
- When not sandboxed: Shows TCP, UDP, ICMP (Simulated), ICMP

The availableCases property handles the sandbox detection automatically.
  </action>
  <verify>
Build succeeds: `swift build 2>&1 | grep -E "(error:|warning:)" || echo "Build clean"`

Verify grep: `grep -n "availableCases" Sources/PingScope/Views/AddHostSheet.swift` should find the updated line
  </verify>
  <done>AddHostSheet ping method picker uses availableCases to filter options based on sandbox status.</done>
</task>

</tasks>

<verification>
- `swift build` compiles without errors
- PingMethod.icmp exists and is included in allCases
- PingMethod.availableCases excludes .icmp when sandboxed (can verify by checking logic)
- PingService handles all 4 PingMethod cases without compiler warnings
- AddHostSheet uses availableCases (not allCases) for picker
- Existing TCP/UDP/icmpSimulated paths unchanged in behavior
</verification>

<success_criteria>
1. PingMethod.swift contains `case icmp` with displayName "ICMP" and defaultPort 0
2. PingMethod.availableCases returns filtered list based on SandboxDetector.isRunningInSandbox
3. PingService.swift routes .icmp to ICMPPinger with proper error handling
4. AddHostSheet.swift uses PingMethod.availableCases in picker
5. All files compile cleanly with no warnings
6. Existing ping methods (tcp, udp, icmpSimulated) work unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/10-true-icmp-support/10-03-SUMMARY.md`
</output>
